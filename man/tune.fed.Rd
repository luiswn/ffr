% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/factor_estimation.R
\name{tune.fed}
\alias{tune.fed}
\title{Tune gamma hyperparameter in functional eigenvalue difference estimator}
\usage{
tune.fed(
  formula,
  data,
  train.share = 0.6,
  gamma_grid = seq(1, 100, by = 1),
  verbose = TRUE
)
}
\arguments{
\item{formula}{An object of class \code{\link[stats]{formula}} specifying the model. Uses the same
format as in \code{\link{flm}}.}

\item{data}{A list containing the variables in the model, following the same format as in \code{\link{flm}}.}

\item{train.share}{A number between 0 and 1 specifying the initial proportion of data to use for training.
Default is 0.6 (60\% of data for initial training).}

\item{gamma_grid}{A numeric vector of candidate gamma values to evaluate. Default is 1 to 100 by 1.}

\item{verbose}{Logical. If TRUE (default), show progress information during computation.}
}
\value{
A list containing:
\item{gamma}{The optimal gamma value}
\item{K}{A named vector of the optimal number of factors for each remaining functional predictor}
\item{optimal_formula}{A formula object from the optimal gamma run containing only the predictors with K > 0}
\item{mse}{A vector of mean squared errors for each gamma value}
\item{gamma_grid}{The vector of gamma values evaluated}
\item{removed_vars}{Character vector of variables removed due to having zero factors during the optimal gamma run}
}
\description{
Uses expanding window time-series cross-validation to find the optimal gamma hyperparameter for the factor estimation
in functional linear models with \code{\link{fed}}.
}
\details{
This function finds the optimal gamma parameter for the \code{\link{fed}} function through
cross-validation with an expanding window approach:

\enumerate{
\item For each gamma value:
\itemize{
\item Estimate the number of factors (K) for each functional predictor using \code{\link{fed}}
\item Create a formula with only the predictors that have K > 0
\item Initialize training with the first \code{train.share} proportion of observations
\item For each subsequent time point:
\itemize{
\item Fit a model using all data up to the current time point
\item Predict the next observation
\item Compute prediction error
}
\item Average the prediction errors to get the mean squared error (MSE)
}
\item Select the gamma value that minimizes MSE
}
}
\examples{
\dontrun{
# Simulate functional data

# Define a Fourier basis function
fourier.basis <- function(evalgrid, nbasis) {
  basis <- matrix(NA, length(evalgrid), nbasis)
  for (k in 1:nbasis) {
    if (k == 1) {
      basis[, k] <- rep(1, length(evalgrid))
    } else {
      if (k \%\% 2 == 0) {
        basis[, k] <- sqrt(2) * sin(2 * (k / 2) * pi * evalgrid)
      } else {
        basis[, k] <- sqrt(2) * cos(2 * floor(k / 2) * pi * evalgrid)
      }
    }
  }
  return(basis)
}

# Function to generate random bivariate beta coefficients
rand.biv.beta <- function(Y.grid, X.grid, K, smoothness_penalty = 1, seed) {
  Y.basis <- matrix(NA, length(Y.grid), K)
  X.basis <- matrix(NA, length(X.grid), K)
  for (k in 1:K) {
    if (k == 1) {
      Y.basis[, k] <- rep(1, length(Y.grid))
      X.basis[, k] <- rep(1, length(X.grid))
    } else {
      if (k \%\% 2 == 0) {
        Y.basis[, k] <- sqrt(2) * sin(2 * (k / 2) * pi * Y.grid)
        X.basis[, k] <- sqrt(2) * sin(2 * (k / 2) * pi * X.grid)
      } else {
        Y.basis[, k] <- sqrt(2) * cos(2 * floor(k / 2) * pi * Y.grid)
        X.basis[, k] <- sqrt(2) * cos(2 * floor(k / 2) * pi * X.grid)
      }
    }
  }

  set.seed(seed)

  weights <- exp(-seq(0, 2, length.out = K))

  # Create coefficient matrix with rank K
  A <- matrix(rnorm(K * K), K, K)

  # Ensure coefficient matrix has exactly rank K through SVD
  svd_A <- svd(A)
  A_rank_K <- svd_A$u \%*\% diag(weights) \%*\% t(svd_A$v)

  # Apply smoothness penalty
  A_smooth <- A_rank_K * smoothness_penalty

  biv.func <- Y.basis \%*\% A_smooth \%*\% t(X.basis)

  return(biv.func)
}

# Set up simulation parameters
Y.gridlength <- 200
X.gridlength <- 200
Y.range <- c(0, ((Y.gridlength - 1) / Y.gridlength))
X.range <- c(0, ((X.gridlength - 1) / X.gridlength))
Y.grid <- seq(Y.range[1], Y.range[2], length.out = Y.gridlength)
X.grid <- seq(X.range[1], X.range[2], length.out = X.gridlength)

K <- 3
T <- 100 # Number of observations

# Generate data
four.basis <- fourier.basis(X.grid, 3 * K)

f <- matrix(rnorm(n = T * K, 0, 1), T, K)
z <- cbind(rep(1, nrow(f)), f)
psi <- four.basis[, 1:K]
pred.func <- f \%*\% t(psi)
eps <- matrix(rnorm(n = T * 2 * K, 0, 1), T, 2 * K)
eps.func <- eps \%*\% t(four.basis[, (K + 1):(3 * K)])

# Create functional predictor
X <- pred.func + eps.func

# Generate coefficient surface
beta <- rand.biv.beta(Y.grid, X.grid, K, seed = 1)

intercept <- rep(3, Y.gridlength)

# Generate error term
u <- matrix(rnorm(n = T * 2 * K, 0, 1), T, 2 * K)
u.func <- u \%*\% t(fourier.basis(Y.grid, 2 * K))

# Generate response
Y <- intercept + (X \%*\% beta / X.gridlength) + u.func

# Find optimal gamma
data <- list(Y = Y, X = X)
result <- tune.fed(Y ~ X, data, gamma_grid = seq(1, 10, by = 1))

# View results
print(result$gamma) # Optimal gamma
print(result$K) # Optimal K values

# Use optimal parameters in flm
model <- flm(result$optimal_formula, data, K = result$K)
}

}
\references{
Otto, S., & Winter, L. (2025). Functional factor regression with an application to electricity price curve modeling.
Wu, J. (2018). Eigenvalue difference test for the number of common factors in the approximate factor models. Economics Letters, 169, 63â€“67.
}
\seealso{
\code{\link{fed}} for factor estimation, \code{\link{flm}} for fitting functional linear models
}
