% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flm.R
\name{flm}
\alias{flm}
\title{Fitting fully functional linear models}
\usage{
flm(formula, data, K, conf.level = 0.95, inference = TRUE)
}
\arguments{
\item{formula}{an object of class \code{\link[stats]{formula}} which is a symbolic description of the model to be fitted.
A model takes the form \code{response ~ regressors}, where \code{response} is the functional response matrix and \code{regressors}
are a series of functional and/or scalar response matrices/vectors. A "regressors" specification of the form
\code{regressor1 + regressor2} indicates a regression on both variables. A formula specification \code{response ~ .} implies
a regression on all other variables in \code{data} besides \code{response}.}

\item{data}{an object of class \code{list} which contains the variables in the model. Each named object within the list is considered
either a functional or a scalar variable. Functional variables are matrices with the number of sample observations T equal the
number of rows and the number of functional observations on an equidistant grid equal the number of columns. Scalar variables
are vectors of length equal to the number of sample observations T, or matrices of column length 1. Additionally, one
can define the \code{type} of each object within the list as either \code{functional} or \code{scalar} for improved reproducibility. While
the number of sample observations must be the same for all objects, the number of functional observations might differ from
functional variable to functional variable.}

\item{K}{a vector of positive integers specifying the number of factors for each functional regressor.
Must be the same length as the number of functional predictors in the model.
Names should match the functional predictor names in \code{data}. For anonymous vectors,
the values are matched according to the order of regressors in the \code{formula}.
See \code{\link{fed}} and \code{\link{tune.fed}} for consistent estimation of the number of factors.}

\item{conf.level}{confidence level (usually between 0.9 and 0.999) used for calculating the confidence regions for
all bivariate function coefficients. Default is 0.95 (95\% confidence).}

\item{inference}{logical. If \code{FALSE}, only the point estimates of all regression objects are computed which speeds up the runtime
significantly. This might be useful in combination with \code{\link{predict.flm}} for large forecasting loops. Default is \code{TRUE}. Note that
\code{inference = FALSE} leads to limited functionality of \code{\link{plot.summary.flm}}.}
}
\value{
An object of class "flm" containing:
\item{info}{List with the matched call, number of observations, and grid information about the data:
\itemize{
\item{call}{The matched function call}
\item{n_obs}{Number of observations}
\item{grid_info}{Grid information for the response and predictors}
}
}
\item{coefficients}{List with three components:
\itemize{
\item{beta}{Functional coefficient surfaces for each predictor}
\item{B}{Matrix of coefficients from finite regression representation}
\item{scalar}{Univariate functional coefficients for the intercept and scalar predictors}
}
}
\item{residuals}{List containing:
\itemize{
\item{Y}{The regression residuals}
\item{X}{The regressors' factor model equation errors}
}
}
\item{fitted}{List containing:
\itemize{
\item{Y}{The fitted values of the response}
\item{factors}{Information about the fitted factor models for the regressors}
}
}
\item{inference}{When \code{inference=TRUE}, a list containing:
\itemize{
\item{covariance}{Bivariate covariance functions}
\item{t_values}{t-values for coefficient surfaces}
\item{conf_bands}{Confidence regions for coefficient surfaces}
\item{conf_level}{The specified confidence level}
}
}
}
\description{
Fits a linear model with functional response and functional/scalar predictors.
This implementation is based on the functional factor regression approach which enables statistical
inference in function-on-function linear regressions.
}
\details{
The function implements the functional factor regression approach for statistical inference in function-on-function linear models,
introduced by Otto & Winter (2025). It handles both functional and scalar predictors and provides confidence regions when \code{inference = TRUE}.
Consult the original paper for details about the method.

Formula specification examples:
\itemize{
\item \code{Y ~ X} - Simple functional regression with one functional predictor
\item \code{Y ~ X1 + X2} - Multiple functional predictors
\item \code{Y ~ X + w} - Mixed functional and scalar predictors
\item \code{Y ~ .} - Use all variables in \code{data} except the response
}
}
\section{Methods}{

The following methods are available for "flm" objects:
\itemize{
\item \code{\link{print.flm}} for basic model output
\item \code{\link{summary.flm}} for detailed model summaries
\item \code{\link{plot.summary.flm}} for visualizing model components
\item \code{\link{predict.flm}} for generating predictions
}
}

\examples{
\dontrun{
# Simulate functional data

# Define a Fourier basis function
fourier.basis <- function(evalgrid, nbasis) {
  basis <- matrix(NA, length(evalgrid), nbasis)
  for (k in 1:nbasis) {
    if (k == 1) {
      basis[, k] <- rep(1, length(evalgrid))
    } else {
      if (k \%\% 2 == 0) {
        basis[, k] <- sqrt(2) * sin(2 * (k / 2) * pi * evalgrid)
      } else {
        basis[, k] <- sqrt(2) * cos(2 * floor(k / 2) * pi * evalgrid)
      }
    }
  }
  return(basis)
}

# Function to generate random bivariate beta coefficients
rand.biv.beta <- function(Y.grid, X.grid, K, smoothness_penalty = 1, seed) {
  Y.basis <- matrix(NA, length(Y.grid), K)
  X.basis <- matrix(NA, length(X.grid), K)
  for (k in 1:K) {
    if (k == 1) {
      Y.basis[, k] <- rep(1, length(Y.grid))
      X.basis[, k] <- rep(1, length(X.grid))
    } else {
      if (k \%\% 2 == 0) {
        Y.basis[, k] <- sqrt(2) * sin(2 * (k / 2) * pi * Y.grid)
        X.basis[, k] <- sqrt(2) * sin(2 * (k / 2) * pi * X.grid)
      } else {
        Y.basis[, k] <- sqrt(2) * cos(2 * floor(k / 2) * pi * Y.grid)
        X.basis[, k] <- sqrt(2) * cos(2 * floor(k / 2) * pi * X.grid)
      }
    }
  }

  set.seed(seed)

  weights <- exp(-seq(0, 2, length.out = K))

  # Create coefficient matrix with rank K
  A <- matrix(rnorm(K * K), K, K)

  # Ensure coefficient matrix has exactly rank K through SVD
  svd_A <- svd(A)
  A_rank_K <- svd_A$u \%*\% diag(weights) \%*\% t(svd_A$v)

  # Apply smoothness penalty
  A_smooth <- A_rank_K * smoothness_penalty

  biv.func <- Y.basis \%*\% A_smooth \%*\% t(X.basis)

  return(biv.func)
}

# Set up simulation parameters
Y.gridlength <- 200
X.gridlength <- 200
Y.range <- c(0, ((Y.gridlength - 1) / Y.gridlength))
X.range <- c(0, ((X.gridlength - 1) / X.gridlength))
Y.grid <- seq(Y.range[1], Y.range[2], length.out = Y.gridlength)
X.grid <- seq(X.range[1], X.range[2], length.out = X.gridlength)

K <- 3
T <- 100 # Number of observations

# Generate data
four.basis <- fourier.basis(X.grid, 3 * K)

f <- matrix(rnorm(n = T * K, 0, 1), T, K)
z <- cbind(rep(1, nrow(f)), f)
psi <- four.basis[, 1:K]
pred.func <- f \%*\% t(psi)
eps <- matrix(rnorm(n = T * 2 * K, 0, 1), T, 2 * K)
eps.func <- eps \%*\% t(four.basis[, (K + 1):(3 * K)])

# Create functional predictor
X <- pred.func + eps.func

# Generate coefficient surface
beta <- rand.biv.beta(Y.grid, X.grid, K, seed = 1)

# Create scalar predictor
w <- as.matrix(rnorm(n = T, 0, 1))
alpha <- cos(Y.grid)

intercept <- rep(3, Y.gridlength)

# Generate error term
u <- matrix(rnorm(n = T * 2 * K, 0, 1), T, 2 * K)
u.func <- u \%*\% t(fourier.basis(Y.grid, 2 * K))

# Generate response
Y <- intercept + (w \%*\% t(alpha)) + (X \%*\% beta / X.gridlength) + u.func

# Fit functional factor regression model
data <- list(Y = Y, X = X, w = list(type = "scalar", data = w))
ffr_model <- flm(Y ~ X + w, data = data, K = c(3), conf.level = 0.99, inference = TRUE)

# Examine model results
summary(ffr_model)
plot(summary(ffr_model))

# Make predictions
pred <- predict(ffr_model, newdata = data)
}

}
\references{
Otto, S., & Winter, L. (2025). Functional factor regression with an application to electricity price curve modeling.
}
\seealso{
\code{\link{summary.flm}} for model summaries
\code{\link{plot.summary.flm}} for summary plots
\code{\link{predict.flm}} for prediction
\code{\link{fed}} and \code{\link{tune.fed}} for factor estimation
\code{\link[stats]{formula}} for formula specification details
}
\keyword{functional}
\keyword{inference}
\keyword{models}
\keyword{regression}
